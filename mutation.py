import random
import spacy

def replace_pos(string1, string2, POS):

    """
    Replace tokens of specific parts of speech (POS) in string1 with corresponding
    tokens of the same POS from string2.
    
    Parameters:
    - string1 (str): The input string where certain POS will be replaced.
    - string2 (str): The reference string from which POS replacements will be taken.
    - POS (list): A list of POS tags to identify which tokens to replace in string1.

    Returns:
    - str: The modified string with replacements of tokens based on specified POS tags.
    
    Possible POS:
    "ADJ": "adjective",
    "ADP": "adposition",
    "ADV": "adverb",
    "AUX": "auxiliary",
    "CONJ": "conjunction",
    "CCONJ": "coordinating conjunction",
    "DET": "determiner",
    "INTJ": "interjection",
    "NOUN": "noun",
    "NUM": "numeral",
    "PART": "particle",
    "PRON": "pronoun",
    "PROPN": "proper noun",
    "PUNCT": "punctuation",
    "SCONJ": "subordinating conjunction",
    "SYM": "symbol",
    "VERB": "verb".
    """
    nlp = spacy.load("en_core_web_sm")
    doc1 = nlp(string1)
    doc2 = nlp(string2)
    
    new_tokens = []
    
    for token1 in doc1:
        if token1.pos_ in POS:
            #generating a list of all matching tokens
            matching_tokens = [token2.text for token2 in doc2 if token2.pos_ == token1.pos_]
            #use a random token if possible, or else use the same
            if matching_tokens:
                new_token = random.choice(matching_tokens)
            else:
                new_token = token1.text
        else:
            new_token = token1.text
        new_tokens.append(new_token)
    
    # Join the modified tokens to form the final string
    result = ' '.join(new_tokens)
    return result

# Requries LLM

def mutate(mutation_prompt, instruction):
    '''
    Mutates the given instruction based on a mutation prompt using a Language Model.

    Parameters:
    - mutation_prompt (str): A prompt or context that guides the mutation process.
    - instruction (str): The original instruction to be mutated.

    Returns:
    str: The mutated instruction generated by the Language Model.
    '''

    return LLM(mutation_prompt + "INSTRUCTION" + instruction)

def lackmarian_mutation(question, working_out):
      """
    Generates a Lackmarian mutation by combining a question and correct working out
    with a standardized header and footer.

    Parameters:
    - question (str): The original question statement.
    - working_out (str): The correct working out for the question.

    Returns:
    str: Lackmarian-mutated instruction to solve the question given the working out

    Example:
    >>> question = "What is the sum of 2 and 3?"
    >>> working_out = "2 + 3 = 5"
    >>> lackmarian_mutated = lackmarian_mutation(question, working_out)
    >>> print(lackmarian_mutated)
    """
    
    header = """ I gave a friend ADVICE to solve a question. Here is his correct working out
QUESTION:"""
    footer = """ The ADVICE I gave was: _____
The ADVICE should be general, and not specific to the question. Give ONLY the ADVICE and no other information. """
    
    return LLM(header + question + "END QUESTION\n" + "WORKING OUT" + working_out + "END WORKING" + footer)
    

    
def lineage_mutation(successful_candidates):
    """
    Generates new tasks based on a list of successful candidates in ascending order of quality.

    Parameters:
    - successful_candidates (list of str): A list of successful instructions in ascending order of quality.

    Returns:
    str: New instruction generated by the LLM
    """
    
    prompt = "GENERATE NEW TASKS BASED ON THE LIST BELOW. THE LIST IS GIVEN IN ORDER OF ASECENDING QUALITY"
    return LLM(prompt + "\n".join(successful_candidates))
    
